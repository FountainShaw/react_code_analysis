/* 
怎么做，才能解决因为一直迭代执行导致UI线程阻塞的问题呢？


其实这涉及到一个优先级的问题，这里我们所谓UI线程被阻塞住，实际上就是说
当前有任务的优先级要高过这段一直迭代执行的代码，所以我们要优先执行他，而非迭代代码
那这又引出另一个问题，我们怎么让原先的迭代代码突然停止，而又在某个特定的时候再次开始执行？
其实迭代我们倒是可以把他进行拆解，分成很多细微的任务，每个任务只执行极短时间
但是什么时候去执行优先级高的任务呢？事实上我们可以一直执行优先级高的任务
当这些任务执行过了或主线程并不是那么忙了，再通知那些被拆分的细微任务接着执行

所以，如果有一个封装好的方法，做到上面的东西，我们就啥都不用干了
还真有，这里介绍一个API，requestIdleCallback
MDN里面是这么描述这个API的： 

window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。
这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，
如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。

你可以在空闲回调函数中调用requestIdleCallback()，
以便在下一次通过事件循环之前调度另一个回调。


其实说白了，这个API，就类似一个setTimeout，我们的DOM操作相当于一个回调函数栈
只是不用你控制主线程啥时候该执行回调，而是当主线程一空闲下来，他就会主动的去执行回调了。
而我们只要一直让这个类似setTimeout的函数递归下去，那么我们就可以一直保证回调栈执行了
而且他为回调函数提供了一个参数deadline
通过检查这个参数，我们就能知道主线程还给我剩下多少时间去执行回调


在react发展的早期，用的就是这个API，但是现在就有专门的实现来进行优化了
但是这并不妨碍我们去理解他的核心工作原理
*/


// 用代码来实现我们上面说的这些逻辑，大概就是以下的内容
function workLoop(deadline) {
  // 是否该停止执行这些优先级低，拆分后的细微任务
  let shouldYield = false

  // 只要下个小单元的任务存在，并且主线程给的时间足够，那就继续执行
  // 当然我们在一次渲染执行完毕之后，也要及时将nextUnitOfWork置空，避免渲染出错
  while (nextUnitOfWork && !shouldYield) {
    // 执行下个单元，并且返回下下个小单元的任务
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
    // 检测剩下的时间是不是足够
    shouldYield = deadline.timeRemaining() < 1
  }

  // 循环迭代整个任务，保证任务能持续进行下去
  requestIdleCallback(workLoop)
}

// 变量需要在某个时刻初始化，否则这个循环无法开始
let nextUnitOfWork = null

// 当主线程空闲时，就开始执行任务循环
requestIdleCallback(workLoop)


/* 
其实以上代码，最核心的就是围绕我们之前说的两个任务
1.能持续将之前所说的迭代任务进行拆分成更加细微的任务
2.这些任务的执行优先级不高，并且不能让他们阻塞主线程的其他任务

其实上面的代码除了performUnitOfWork这个函数的实现和nextUnitWork的初始化之外
其他的基本上都已经算是比较完整了，要最终完成这些，就必须涉及到另外一个概念：Fiber
即每一个拆分开来的细微任务是什么，以及怎么进行下一步的拆分
*/
